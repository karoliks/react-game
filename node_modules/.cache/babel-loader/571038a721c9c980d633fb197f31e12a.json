{"ast":null,"code":"import store from \"../../config/store\";\nimport { SPRITE_SIZE, MAP_WIDTH, MAP_HEIGHT } from \"../../config/constants\";\nexport default function handleMovement(player) {\n  // find new position given old position and desired direction\n  function getNewPosition(oldPos, direction) {\n    switch (direction) {\n      case \"WEST\":\n        return [oldPos[0] - SPRITE_SIZE, oldPos[1]];\n\n      case \"EAST\":\n        return [oldPos[0] + SPRITE_SIZE, oldPos[1]];\n\n      case \"NORTH\":\n        return [oldPos[0], oldPos[1] - SPRITE_SIZE];\n\n      case \"SOUTH\":\n        return [oldPos[0], oldPos[1] + SPRITE_SIZE];\n    }\n  } //   boolean function to determine whether the sprite is at an edge\n\n\n  function observeBoundaries(oldPos, newPos) {\n    return newPos[0] >= 0 && newPos[0] <= MAP_WIDTH - SPRITE_SIZE && newPos[1] >= 0 && newPos[1] <= MAP_HEIGHT - SPRITE_SIZE;\n  } // find the location to the relevant sprite on the spirte image\n\n\n  function getSpriteLocation(direction, walkIndex) {\n    switch (direction) {\n      case \"SOUTH\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 0}px`;\n\n      case \"EAST\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 1}px`;\n\n      case \"WEST\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 2}px`;\n\n      case \"NORTH\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 3}px`;\n    }\n  }\n\n  function getWalkIndex() {\n    const walkIndex = store.getState().player.walkIndex;\n    return walkIndex >= 8 ? 0 : walkIndex + 1;\n  } //   boolean function to determine whether the sprite is trying to pass an object\n\n\n  function observeImpassable(oldPos, newPos) {\n    const tiles = store.getState().map.tiles;\n    const y = newPos[1] / SPRITE_SIZE;\n    const x = newPos[0] / SPRITE_SIZE;\n    const nextTile = tiles[y][x];\n    return nextTile < 5;\n  } // Move sprite to desired location\n\n\n  function dispatchMove(direction, newPos) {\n    const walkIndex = getWalkIndex();\n    store.dispatch({\n      type: \"MOVE_PLAYER\",\n      payload: {\n        position: newPos,\n        direction: direction,\n        spriteLocation: getSpriteLocation(walkIndex, direction)\n      }\n    });\n  } // Check if desired move is possible, and if possible, move the sprite\n\n\n  function attemtMove(direction) {\n    const oldPos = store.getState().player.position;\n    const newPos = getNewPosition(oldPos, direction);\n\n    if (observeBoundaries(oldPos, newPos) && observeImpassable(oldPos, newPos)) {\n      dispatchMove(direction, newPos);\n    }\n  } // translate keycodes to directions\n\n\n  function handleKeyDown(e) {\n    e.preventDefault();\n\n    switch (e.keyCode) {\n      case 37:\n        return attemtMove(\"WEST\");\n\n      case 38:\n        return attemtMove(\"NORTH\");\n\n      case 39:\n        return attemtMove(\"EAST\");\n\n      case 40:\n        return attemtMove(\"SOUTH\");\n\n      default:\n        console.log(e.keyCode);\n    }\n  }\n\n  window.addEventListener(\"keydown\", e => {\n    handleKeyDown(e);\n  });\n  return player;\n}","map":{"version":3,"sources":["/home/karoline/GitHub/react-game/src/features/player/movement.js"],"names":["store","SPRITE_SIZE","MAP_WIDTH","MAP_HEIGHT","handleMovement","player","getNewPosition","oldPos","direction","observeBoundaries","newPos","getSpriteLocation","walkIndex","getWalkIndex","getState","observeImpassable","tiles","map","y","x","nextTile","dispatchMove","dispatch","type","payload","position","spriteLocation","attemtMove","handleKeyDown","e","preventDefault","keyCode","console","log","window","addEventListener"],"mappings":"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","sourcesContent":["import store from \"../../config/store\";\nimport { SPRITE_SIZE, MAP_WIDTH, MAP_HEIGHT } from \"../../config/constants\";\n\nexport default function handleMovement(player) {\n  // find new position given old position and desired direction\n  function getNewPosition(oldPos, direction) {\n    switch (direction) {\n      case \"WEST\":\n        return [oldPos[0] - SPRITE_SIZE, oldPos[1]];\n      case \"EAST\":\n        return [oldPos[0] + SPRITE_SIZE, oldPos[1]];\n      case \"NORTH\":\n        return [oldPos[0], oldPos[1] - SPRITE_SIZE];\n      case \"SOUTH\":\n        return [oldPos[0], oldPos[1] + SPRITE_SIZE];\n    }\n  }\n\n  //   boolean function to determine whether the sprite is at an edge\n  function observeBoundaries(oldPos, newPos) {\n    return (\n      newPos[0] >= 0 &&\n      newPos[0] <= MAP_WIDTH - SPRITE_SIZE &&\n      newPos[1] >= 0 &&\n      newPos[1] <= MAP_HEIGHT - SPRITE_SIZE\n    );\n  }\n\n  // find the location to the relevant sprite on the spirte image\n  function getSpriteLocation(direction, walkIndex) {\n    switch (direction) {\n      case \"SOUTH\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 0}px`;\n      case \"EAST\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 1}px`;\n      case \"WEST\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 2}px`;\n      case \"NORTH\":\n        return `${SPRITE_SIZE * walkIndex}px ${SPRITE_SIZE * 3}px`;\n    }\n  }\n\n  function getWalkIndex() {\n    const walkIndex = store.getState().player.walkIndex;\n    return walkIndex >= 8 ? 0 : walkIndex + 1;\n  }\n\n  //   boolean function to determine whether the sprite is trying to pass an object\n  function observeImpassable(oldPos, newPos) {\n    const tiles = store.getState().map.tiles;\n    const y = newPos[1] / SPRITE_SIZE;\n    const x = newPos[0] / SPRITE_SIZE;\n    const nextTile = tiles[y][x];\n    return nextTile < 5;\n  }\n\n  // Move sprite to desired location\n  function dispatchMove(direction, newPos) {\n    const walkIndex = getWalkIndex();\n    store.dispatch({\n      type: \"MOVE_PLAYER\",\n      payload: {\n        position: newPos,\n        direction: direction,\n        spriteLocation: getSpriteLocation(walkIndex, direction),\n      },\n    });\n  }\n\n  // Check if desired move is possible, and if possible, move the sprite\n  function attemtMove(direction) {\n    const oldPos = store.getState().player.position;\n    const newPos = getNewPosition(oldPos, direction);\n\n    if (\n      observeBoundaries(oldPos, newPos) &&\n      observeImpassable(oldPos, newPos)\n    ) {\n      dispatchMove(direction, newPos);\n    }\n  }\n\n  // translate keycodes to directions\n  function handleKeyDown(e) {\n    e.preventDefault();\n    switch (e.keyCode) {\n      case 37:\n        return attemtMove(\"WEST\");\n      case 38:\n        return attemtMove(\"NORTH\");\n      case 39:\n        return attemtMove(\"EAST\");\n      case 40:\n        return attemtMove(\"SOUTH\");\n      default:\n        console.log(e.keyCode);\n    }\n  }\n\n  window.addEventListener(\"keydown\", (e) => {\n    handleKeyDown(e);\n  });\n\n  return player;\n}\n"]},"metadata":{},"sourceType":"module"}